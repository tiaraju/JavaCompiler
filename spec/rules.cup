parser code  {: 
  public void report_error(String message, Object info) {
    StringBuffer m = new StringBuffer("Error ");

    if (info instanceof java_cup.runtime.Symbol) 
      m.append( "("+info.toString()+")" );
     
    m.append(" : "+message);
   
    System.out.println(m);
  }
   
  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  }
:};

terminal BOOLEAN; // 
terminal BYTE, SHORT, INT, LONG, CHAR; // OK
terminal D, E, F, X, L; // 
terminal TRUE, FALSE; //  
terminal NULL; // ok
terminal THREADSAFE; //
terminal FLOAT, DOUBLE; // 
terminal LBRACK, RBRACK; // 
terminal DOT; // 
terminal SEMICOLON, MULT, COMMA, LBRACE, RBRACE, EQ, LPAREN, RPAREN, COLON;
terminal PACKAGE; //
terminal IMPORT; // 
terminal PUBLIC, PROTECTED, PRIVATE; // 
terminal STATIC; // 
terminal ABSTRACT, FINAL, NATIVE, SYNCHRONIZED, TRANSIENT, VOLATILE;
terminal CLASS; // 
terminal EXTENDS; // 
terminal IMPLEMENTS; // interfaces
terminal VOID; // method_header
terminal THROWS; // throws
terminal THIS, SUPER; // ok
terminal INTERFACE; // interface_declaration
terminal IF, ELSE; // if_then_statement, if_then_else_statement
terminal SWITCH; // switch_statement
terminal CASE, DEFAULT; // switch_label
terminal DO, WHILE; // while_statement, do_statement
terminal FOR; // for_statement
terminal BREAK; // break_statement
terminal CONTINUE; // continue_statement
terminal RETURN; // return_statement
terminal THROW; // throw_statement
terminal TRY; // try_statement
terminal CATCH; // catch_clause
terminal FINALLY; // finally
terminal NEW; // class_instance_creation_expression
terminal PLUSPLUS; // postincrement_expression
terminal MINUSMINUS; // postdecrement_expression
terminal PLUS, MINUS, COMP, NOT, DIV, MOD;
terminal LSHIFT, RSHIFT, URSHIFT; // shift_expression
terminal LT, GT, LTEQ, GTEQ, INSTANCEOF; // relational_expression
terminal EQEQ, NOTEQ; // equality_expression
terminal AND; // and_expression
terminal XOR; // exclusive_or_expression
terminal OR;  // inclusive_or_expression
terminal ANDAND; // conditional_and_expression
terminal OROR; // conditional_or_expression
terminal QUESTION; // conditional_expression
terminal MULTEQ, DIVEQ, MODEQ, PLUSEQ, MINUSEQ; // assignment_operator
terminal LSHIFTEQ, RSHIFTEQ, URSHIFTEQ; // assignment_operator
terminal ANDEQ, XOREQ, OREQ; // assignment_operator

terminal java.lang.Number INTEGER_LITERAL;
terminal java.lang.Number FLOATING_POINT_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.Character character; //ok
terminal java.lang.String STRING_LITERAL;
terminal java.lang.String CHARLITERAL;
terminal java.lang.String identifier; // ok
terminal NULL_LITERAL;

// Reserved but unused:
terminal CONST, GOTO;

// 19.2) The Syntactic Grammar
non terminal goal;

// 19.3) Lexical Structure
non terminal literal;

// 19.4) Types, Values, and Variables
non terminal type, primitive_type, numeric_type;
non terminal integral_type, floating_point_type;
non terminal reference_type;
non terminal class_or_interface_type;
non terminal class_type, interface_type;
non terminal array_type;
non terminal type_specifier; //ok
non terminal arglist; //ok


// 19.5) Names
non terminal name, simple_name, qualified_name;

// 19.6) Packages
non terminal compilation_unit;
non terminal package_declaration_opt, package_declaration;
non terminal package_statement_opt; // ok
non terminal import_declarations_opt, import_declarations;
non terminal type_declarations_opt, type_declarations;
non terminal import_declaration;
non terminal single_type_import_declaration;
non terminal type_import_on_demand_declaration;
non terminal type_declaration;

// 19.7) Productions used only in the LALR(1) grammar
non terminal modifiers_opt, modifiers, modifier;

// 19.8.1) Class Declaration
non terminal class_name;  //ok
non terminal class_declaration, super_cl, super_opt;
non terminal interfaces, interfaces_opt, interface_type_list;
non terminal class_body;
non terminal class_body_declarations, class_body_declarations_opt;
non terminal class_body_declaration, class_member_declaration;
non terminal extends_class_opt;

// 19.8.2) Field Declarations
non terminal field_declaration; //ok
non terminal variable_declaration; // ok
non terminal variable_declarators, variable_declarator;
non terminal variable_declarator_id, variable_initializer;

// 19.8.3) Method Declarations
non terminal method_declaration, method_header, method_declarator;
non terminal formal_parameter_list_opt, formal_parameter_list;
non terminal formal_parameter;
non terminal throws_opt, throws;
non terminal class_type_list, method_body;

// 19.8.4) Static Initializers
non terminal static_initializer;

// 19.8.5) Constructor Declarations
non terminal constructor_declaration; // ok
non terminal constructor_body;
non terminal explicit_constructor_invocation;

// 19.9.1) Interface Declarations
non terminal interface_type_list, interfaces, interface_opt // ok
non terminal interface_name; //ok
non terminal interface_declaration;
non terminal extends_interfaces_opt, extends_interfaces;
non terminal interface_body;
non terminal interface_member_declarations_opt, interface_member_declarations;
non terminal interface_member_declaration, constant_declaration;
non terminal abstract_method_declaration;

// 19.10) Arrays
non terminal array_initializer;
non terminal variable_initializers;

// 19.11) Blocks and Statements
non terminal block;
non terminal block_statements_opt, block_statements, block_statement;
non terminal local_variable_declaration_statement, local_variable_declaration;
non terminal statement; //ok
non terminal statement_no_short_if;
non terminal statement_without_trailing_substatement;
non terminal empty_statement;
non terminal labeled_statement, labeled_statement_no_short_if;
non terminal expression_statement, statement_expression;
non terminal if_statement; //ok
non terminal if_then_else_statement, if_then_else_statement_no_short_if;
non terminal switch_statement, switch_block;
non terminal switch_block_statement_groups;
non terminal switch_block_statement_group;
non terminal switch_labels, switch_label;
non terminal while_statement, while_statement_no_short_if;
non terminal do_statement; //ok
non terminal for_statement; // ok
non terminal for_statement_no_short_if;
non terminal for_init_opt, for_init;
non terminal for_update_opt, for_update;
non terminal statement_expression_list;
non terminal identifier_opt;
non terminal break_statement, continue_statement;
non terminal return_statement, throw_statement;
non terminal synchronized_statement, try_statement;
non terminal catches_opt, catches, catch_clause;
non terminal finally;

// 19.12) Expressions
non terminal primary, primary_no_new_array;
non terminal class_instance_creation_expression;
non terminal argument_list_opt, argument_list;
non terminal array_creation_expression;
non terminal dim_exprs, dim_expr, dims_opt, dims;
non terminal field_access, method_invocation, array_access;
non terminal postfix_expression;
non terminal postincrement_expression, postdecrement_expression;
non terminal unary_expression, unary_expression_not_plus_minus;
non terminal preincrement_expression, predecrement_expression;
non terminal cast_expression;
non terminal multiplicative_expression, additive_expression;
non terminal shift_expression, relational_expression, equality_expression;
non terminal and_expression, exclusive_or_expression, inclusive_or_expression;
non terminal conditional_and_expression, conditional_or_expression;
non terminal conditional_expression, assignment_expression;
non terminal assignment;
non terminal left_hand_side;
non terminal assignment_operator;
non terminal expression_opt, expression;
non terminal constant_expression;
non terminal bit_expression; //ok
non terminal casting_expression; //ok
non terminal creating_expression; // ok
non terminal numeric_expression; // ok
non terminal testing_expression; // ok
non terminal logical_expression; // ok
non terminal string_expression; // ok

expression ::= 
      | identifier 
      | LPAREN expression RPAREN  
      | expression LPAREN arglist_opt RPAREN 
      | expression LBRACK expression RBRACK 
      | expression DOT expression 
      | expression COMMA expression 
      | expression INSTANCEOF class_or_interface_name 
	;

//Aux
non terminal exponent_part;

start with goal;

// 19.2) The Syntactic Grammar
goal ::=	compilation_unit
	;
//RULES

arglist ::= 
      expression
      | arglist COMMA expression
     ;
     
bit_expression ::= 
      COMP expression 
      | expression RSHIFTEQ expression
      | expression LSHIFT expression
      | expression RSHIFT expression
      | expression URSHIFT expression 
     ;
     
casting_expression ::= 
      LPAREN type RPAREN expression 
     ; 
     
extends_class_opt ::= | EXTENDS class_name ;

interface_type_list ::= interface_type | interface_type_list COMMA interface_type; //ok
interfaces ::=	IMPLEMENTS interface_type_list; //ok
interface_opt ::= | interfaces ; //ok

class_declaration ::= 
      modifier CLASS identifier 
      extends_class_opt
      interface_opt
      LBRACE field_declaration RBRACE
      ;

class_or_interface_name ::= 
      identifier 
      | package_name DOT identifier 
     ;
     
class_name ::= class_or_interface_name;

interface_name ::= class_or_interface_name;

package_statement_opt ::= | package_statement;
compilation_unit ::= 
      package_statement_opt
      import_statement 
      type_declaration 
     ;
     
constructor_declaration ::= 
      modifier identifier LPAREN parameter_list_opt RPAREN
      statement_block 
     ;
     
expression_bracks_opt ::= | LBRACK expression RLBRACK ;
creating_expression ::= 
      NEW classe_name LPAREN arglist_opt RPAREN 
      | NEW type_specifier expression_bracks_opt LBRACK RLBRACK 
      | NEW LPAREN expression RPAREN 
	;
	
do_statement ::=
		DO statement WHILE LPAREN expression RPAREN SEMICOLON
	;
	
arglist_opt ::= | arglist ;
class_or_interface_name ::= class_name | interface_name ;
expression ::= 
      numeric_expression 
      | testing_expression 
      | logical_expression 
      | string_expression 
      | bit_expression 
      | casting_expression 
      | creating_expression 
      | literal_expression 
      | NULL 
      | SUPER 
      | THIS 
      | identifier 
      | LPAREN expression RPAREN  
      | expression LPAREN arglist_opt RPAREN 
      | expression LBRACK expression RBRACK 
      | expression DOT expression 
      | expression COMMA expression 
      | expression INSTANCEOF class_or_interface_name 
	;
	
types_declarations ::= 
	  method_declaration 
      | constructor_declaration 
      | variable_declaration 
	;
	
field_declaration ::= 
      types_declarations 
      | static_initializer 
      | SEMICOLON
     ;

expression_opt ::= | expression ;
expression_semicolon ::= expression SEMICOLON ;

part_for ::= variable_declaration | expression_semicolon | SEMICOLON ;
for_statement ::= 
      FOR LPAREN  
      part_for  
      expression_opt SEMICOLON
      expression_opt SEMICOLON 
      RPAREN statement 
	;
	
else_opt ::= | ELSE statement ;
if_statement ::= 
      IF LPAREN expression RPAREN statement 
      else_opt 
     ;
     
import_statement ::= 
     IMPORT package_name DOT MULT SEMICOLON
     | IMPORT class_name SEMICOLON
     | IMPORT interface_name SEMICOLON
	;      
	
interface_declaration ::=
		modifier INTERFACE identifier extends_interfaces_opt 
			interface_body
	;
extends_interfaces_opt ::=
	|	extends_interfaces
	;
extends_interfaces ::=
		EXTENDS interface_name
	|	extends_interfaces COMMA interface_name
	;
	
interface_body ::=
		LBRACE interface_member_declarations_opt RBRACE
	;
interface_member_declarations_opt ::=
	|	interface_member_declarations
	;
interface_member_declarations ::=
		field_declaration
	|	interface_member_declarations field_declaration
	;
	  
interface_name ::= 
      identifier 
      |  package_name DOT identifier
	;

literal_expression ::= 
      INTEGER_LITERAL 
      | FLOAT_LITERAL 
      | string               //VEEER
      | character 
	;
	
logical_expression ::= 
       NOT expression 
      | expression AND expression
      | expression ANDEQ expression 
      | expression OR expression
      | expression OREQ expression 
      | expression XOR expression
      | expression XOREQ expression 
      | expression ANDAND expression
      | expression OROR expression 
      | expression MOD expression
      | expression MODEQ expression 
      | expression QUESTION expression COLON expression
      | TRUE 
      | FALSE 
	;

parameter_list_opt ::= | parameter_list;
sttm_block_semicolon ::= statement_block | SEMICOLON ;
method_declaration ::= 
		modifier type identifier 
		LPAREN parameter_list_opt RPAREN LBRACK RBRACK
		sttm_block_semicolon
	;
	
minus_exp ::=  MINUS expression;
minusminus_exp ::=  MINUSMINUS expression;
plusplus_exp ::=  PLUSPLUS expression;
exp_minusminus ::=   expression MINUSMINUS;
exp_plusplus ::=   expression PLUSPLUS;

numeric_expression ::= 
      minus_exp
      | minusminus_exp
      | plusplus_exp 
      | exp_plusplus
      | exp_minusminus
      | expression PLUS expression
      | expression PLUSEQ expression 
      | expression MINUS expression 
      | expression MINUSEQ expression
      | expression MULT expression
      | expression MULTEQ expression 
      | expression DIV expression
      | expression DIVEQ expression
      | expression MOD expression 
      | expression MODEQ expression  
	;
	
package_name ::= 
      identifier 
      | package_name DOT identifier 
	;
	
package_statement ::= 
      PACKAGE package_name SEMICOLON
     ;
     
parameter ::= 
      type identifier LBRACK RBRACK 
	;  
	
parameter_list ::= 
      parameter COMMA parameter 
	;
	
identifier_opt ::= | identifier
	;
	
statement ::=	
	variable_declaration
	|	expression SEMICOLON
	|   statement_block
	|	if_statement
	|	do_statement
	|	while_statement
	|	for_statement
	|	try_statement
	|	switch_statement
	|	SYNCHRONIZED LPAREN expression RPAREN statement
	|	RETURN expression_opt SEMICOLON   
	|	THROW expression SEMICOLON
	|   identifier COLON statement
	|	BREAK identifier_opt SEMICOLON 
    |   CONTINUE identifier_opt SEMICOLON 
    |   SEMICOLON 
	;
	
statement_block  ::=
		LBRACE statement RBRACE
	;

static_initializer ::=
		static statement_block 
	;

string_expression ::= 
		expression 
        PLUS 
      	| PLUSEQ  
      expression  
    ;

switch_statement ::=
	    switch LPAREN expression RPAREN LBRACE
		 case expression COLON
		| default COLON
		| statment
		RBRACE
	;

testing_expression ::= 
       expression 
       GT
      | LT 
      | GTEQ
      | LTEQ 
      | EQEQ 
      | NOTEQ
      expression  
    ; 
      
finally_opt ::= | FINALLY statement 
	;
try_statement ::=
		TRY statement
		CATCH LPAREN parameter RPAREN statement 
      	finally_opt
	;

type ::= 
      type_specifier LBRACK RBRACK
     ;
doc_comment_opt ::= | doc_comment ;
class_or_interface_declaration ::= class_declaration | interface_declaration;
type_declaration ::= 
      doc_comment_opt class_or_interface_declaration SEMICOLON 
     ;

type_specifier ::= 
      BOOLEAN 
      | BYTE 
      | CHAR 
      | SHORT 
      | INT 
      | FLOAT 
      | LONG 
      | DOUBLE 
      | class_name 
      | interface_name 
	;
variable_declarator_loop ::= variable_declarator | variable_declarator COMMA variable_declarator ;
variable_declaration ::=
		modifier type variable_declarator_loop 
	;
eq_variable_initializer_opt ::= | EQ variable_initializer 
	;
variable_declarator ::=
		identifier LBRACK RBRACK eq_variable_initializer_opt
	;
		
comma_opt ::= | COMMA
	;
variable_initializer_opt ::= | variable_initializer 
      COMMA variable_initializer comma_opt 

variable_initializer ::=
		expression
	|	LBRACE variable_initializer_opt   RBRACE
	;
	
while_statement ::=
		WHILE LPAREN expression RPAREN statement
	;
	
	
//Auxs
//exponent_part  ::=  "e" [ "+" | "-" ] decimal_digits 
	
// nao fiz decimal_digits, doc_comment, exponent_part, identifier, float_literal, float_type_suffix
// field_declaration  ta estranho, refzer